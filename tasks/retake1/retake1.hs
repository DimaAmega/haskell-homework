{-# LANGUAGE FlexibleContexts #-}

import Data.Semigroup
import Data.Monoid
import Control.Monad.Writer

-- 1. Prelude говорит, то значением выражения div x y для целых x и y
-- является частное x и y, округленное вниз (то есть к минус бесконечности).
-- Однако выражение

-- -7 `div` 3

-- возвращает -2, а не -3, как можно было ожидать. Объясните подробно,
-- почему так получается и как можно получить правильный результат
-- целочисленного деления -7 на 3.

-- Указание. Можно пользоваться командой :i интерпретатора GHCi,
-- печатающей информацию о введенных именах. Полезная информация также
-- содержится в Prelude и разделах 3.4 и 4.4.2 Haskell 2010 Language
-- Report.

------------------------------- ОТВЕТ ---------------------------------------
-- В основе языка haskell лежит ламбда исчисление, в котором определены
-- 2 операции: аппликация и λ-абстракция. 
-- 
-- fun fact: косая черта в Haskell как раз напоминает λ
-- 
-- В haskell λ-абстракцию называют просто функцией, а операторы - это на самом 
-- деле синтаксический сахар для аппликации двух (или одного) терма к 
-- λ-абстракциям. Например 2 + 3, на самом деле транслируется в core haskell
-- в вид (+) 2 3
-- Теперь подробнее:
-- В Haskell функции, предназначенные для инфиксной формы применения, называют 
-- операторами, их объявление заключено в скобки.
-- Если в ghci  прописать ":i div" и  ":i -", то увидим следущее:
--              Prelude> :i div
--              type Integral :: * -> Constraint
--              class (Real a, Enum a) => Integral a where
--                ...
--                div :: a -> a -> a
--                ...
--                      -- Defined in ‘GHC.Real’
--              infixl 7 `div`
--              Prelude> :i -
--              type Num :: * -> Constraint
--              class Num a where
--                ...
-- IMPORTANT -->  (-) :: a -> a -> a
--                ...
--                      -- Defined in ‘GHC.Num’
--              infixl 6 -
-- 
-- Видим, что минус заключен в скобки, значит семанически является 
-- бинарным, левоассоциативным оператором с приоритетом 6
--
-- div же просто является функцией, но используя ее в инфиксной 
-- форме записи (используя специальные квоты ``) она является 
-- бинарным, левоассоциативным оператором с приоритетом 7
--
-- Но в записи "-7 `div` 3"
-- минус является префиксным оператором (единственный унарный оператор 
-- в Haskell) и реализует префикс отрицания. В документации Haskell сказано,
-- что префиксный минус обладает таким же приоритетом как и бинарный минус,
-- то есть (как можно щаметить выше) приоритет равняется 6.
-- Также в Haskell определена функция negate, давайте проинспектируем ее в 
-- GHCI
--              Prelude> :i negate
--              type Num :: * -> Constraint
--              class Num a where
--                ...
--                negate :: a -> a
--                ...
--                      -- Defined in ‘GHC.Num’
--
-- В core Haskell запись вида "-a" как раз транслируется в "negate a"
-- и тут как всегда нет никакой магии, просто применение функции.
--
-- Таким образом у предиката отрицания приоритет ниже чем у 
-- оператора `div` получается что сначала выполнится 7 `div` 3
-- а только потом negate от результата, negate 2, получая -2
--
-- Избежать данного эффекта очень просто, вот несколько вариантов:
-- negate 7 `div` 3     (у апликации наивысший приоритет)
-- (-7) `div` 3         (расставляем скобки)
-- div (-7) 3           (расставляем скобки)
-- div (negate 7) 3     (расставляем скобки)
------------------------------------------------------------------------------

-- 2. Следующая задача была предложена на контрольной в середине
-- весеннего семестра, однако все решения были излишне сложными.

-- Без использования рекурсии напишите функцию abbrev :: [String] -> String,
-- которая в заданном списке имен людей выполняет сокращение всех
-- имен, кроме фамилии, до инициалов. Фамилией считается последнее
-- слово. Например:

-- > putStrLn $ abbrev ["Синицин"]
-- "Синицин"
-- > putStrLn $ abbrev ["Сергей", "Есенин"]
-- "С.Есенин"
-- putStrLn $ abbrev ["Игорь", "Федорович", "Поддубный"]
-- "И.Ф.Поддубный"
-- putStrLn $ abbrev ["Иоганн", "Хризостом", "Вольфганг", "Амадей", "Моцарт"]
-- "И.Х.В.А.Моцарт"

-- Решение должно удовлетворять следующим условиям.

-- (а) Оно должно состоять из одной строчки, не считая объявления типа.
-- (б) Следует использовать правую свертку для непустых списков.
-- (в) Функция должна иметь временную сложность O(n), где n — длина
-- списка, но не общая длина слов в списке.
-- (г) Не следует использовать функцию (++) там, где можно обойтись
-- более простыми функциями.

abbrev :: [String] -> String
abbrev = foldr1 (\w acc -> head w : '.' : acc)

-- 3. Напишите рекурсивную функцию

foldMapList :: Monoid m => (a -> m) -> [a] -> m
foldMapList f [] = mempty
foldMapList f (x:xs) = f x <> foldMapList f xs


-- которая может использоваться для объявления членства типа списков
-- в классе Foldable.

-- 4. В Prelude функции foldr определена через foldMap следующим образом.

-- foldr f z t = appEndo (foldMap (Endo . f) t) z

-- С учетом вашего ответа на предыдущий вопрос объясните, как работает
-- это определение, если t — список, и почему оно эквивалентно
-- обычному определению из лекции 5.

-- Рассмотрим в начале выражение "foldMap (Endo . f) t"
-- вспомним сигнатуру f: 
-- f :: a -> b -> b
-- В нашем случае a - элементы списка, тогда получается, что
-- применяя (Endo . f) к элементам списка, мы получаем моноид 
-- эндоморфизмов с функцией сигнатуры b -> b внутри. 
-- Причем эта функция хранит в своем замыкании элемент списка.
-- Это очень важный момент!
-- 
-- пусть есть спискок [a1, a2, ... an]
-- foldMap (Endo . f) [a1, a2, ... an]
-- Отметим, что в случае моноида эндоморфизмов оператор <>
-- реализуется как:
-- (Endo f) <> (Endo g) = Endo (f . g)
-- редуцируется до
-- A = (Endo . f) a1 <> ((Endo . f) a2 <> ((Endo . f) a3 <> ... <> (Endo . f) an))
-- A = Endo (f a1) <> (Endo (f a2) <> (Endo (f a3) <> ... <> Endo (f an)))
-- A = Endo ((f a1) . (f a2) . (f a3) ... f (an))
-- Очевидно, что A также является моноидом эндоморфизмов
-- Далее мы применяем appEndo к A с начальным значением z, запуская вычисление
-- appEndo A z
-- Теперь уже не сложно понять, что в результате редукции получится:
-- f a1 ( ... (f an-2 (f an-1 (f an z))))
-- Это как раз соответствует определению правой свертки для функции 
-- f с нач значением z над эллементами [a1, a2, ..., an]
-- 5. Рассмотрим следующие определения.

l :: [String]
l = ["ab", "cd", "ef"]

f1 :: [String] -> String -> String
f1 = mconcat . map showString

f2 :: [String] -> String -> String
f2 = appEndo . mconcat . map (Endo . showString)

-- Объясните, что возвращают f1 и f2, в чем между ними разница и какова ее причина.

-- Указание. Определение моноидных операций на различных типах, в том
-- числе на типе функций (a -> b) и типе эндоморфизмов (Endo a),
-- находятся в модуле Data.Semigroup.

-- Результаты выполнения функций
-- СЛУЧАЙ f1
-- В данном случае используется следующая реализация 
-- (см https://hackage.haskell.org/package/base-4.15.0.0/docs/src/GHC-Base.html#Semigroup)
-- instance Semigroup b => Semigroup (a -> b) where
--         f <> g = \x -> f x <> g x
--         stimes n f e = stimes n (f e)
--
-- рассмотрим пример вычисления f1 l "|" == "ab|cd|ef|"
-- рассмотрим аппликацию f1 ["ab", "cd", "ef"]
-- Будем ее редуцировать:
-- mconcat (map showString ["ab", "cd", "ef"])
-- mconcat [Shows "ab", Shows "cd", Shows "ef"]
-- foldr (<>) mempty [Shows "ab", Shows "cd", Shows "ef"]
-- Shows "ab" <> (Shows "cd" <> (Shows "ef" <> mempty))
-- Shows "ab" <> (Shows "cd" <> Shows "ef") 
-- Shows "ab" <> \x -> Shows "cd" x <> Shows "ef" x
-- \y -> Shows "ab" y <> (\x -> Shows "cd" x <> Shows "ef" x) y
-- \y -> Shows "ab" y <> Shows "cd" y <> Shows "ef" y
--
-- Теперь применим к этому терму "|"
-- (\y -> Shows "ab" y <> Shows "cd" y <> Shows "ef" y) "|"
-- Shows "ab" "|" <> Shows "cd" "|" <> Shows "ef" "|"
-- Shows "ab" "|" <> Shows "cd" "|" <> Shows "ef" "|"
-- "ab|" <> "cd|" <> "ef|"
-- "ab|cd|ef|"
-- Теперь уже становится очевидно, что f1 принимает список строк 
-- и еще одну строку A. К каждой строке из списка 
-- конкатенирует строку A и полученные строки тоже конкатенирует
--
-- СЛУЧАЙ f2
-- в данном случае будет использоваться следующая реализация
-- instance Semigroup (Endo a) where
--   Endo f <> Endo g = Endo (f . g)
-- рассмотрим пример вычисления f2 l "|" == "abcdef|"
-- рассмотрим аппликацию f2 ["ab", "cd", "ef"]
-- Будем ее редуцировать:
-- appEndo $ mconcat $ map (Endo . showString) ["ab", "cd", "ef"]
-- appEndo $ mconcat [Endo (Shows "ab"), Endo (Shows "cd"), Endo (Shows "ef")]
-- appEndo $ Endo (Shows "ab") <> Endo (Shows "cd") <> Endo (Shows "ef")
-- appEndo $ Endo (Shows "ab" . Shows "cd" . Shows "ef")
-- Теперь применим к этому терму "|"
-- appEndo Endo (Shows "ab" . Shows "cd" . Shows "ef") "|"
-- Очевидно получаем
-- "abcdef|"
-- Теперь уже становится очевидно, что f2 принимает список строк
-- и еще одну строку A. Конкатенирует все строки списка и в конце
-- конкатенирует к полученному результату A.
--
-- Разница происходит именно от того, что mconcat работает с разными 
-- сущностями, в первом случае mconcat применяется к [Shows]
-- а во втором к [Endo]. Разумеется реализации <> ведут себя по разному
-- в случае моноида эндоморфизнов и разностных списков. (реализации были приведены
-- в начале каждого рассматриваемого случая)
-- 6. Напишите функцию

minMax :: [Int] -> (Int, Int)
minMax = undefined

-- которая возвращает пару, состоящую из минимального и максимального
-- элементов непустого списка. Она должна использовать следующую
-- рекурсивную функцию, которая выполняет основную работу.

minMaxLoop :: [Int] -> Writer (Min Int, Max Int) ()
minMaxLoop = undefined

-- Определения типов Min a и Max a, являющихся моноидами с операциями
-- min и max, соответственно, находятся в модулях Data.Semigroup и
-- Data.Monoid. Они аналогичны моноидам Sum a и Product a,
-- рассмотренным на лекциях.

-- Функция minMaxLoop не должна явно использовать операторы сравнения, а также
-- функции min, max, minimum и maximum. В определении minMax можно использовать
-- функцию execWriter, определенную в Control.Monad.Writer.

-- 7. Подставьте определения функций flip и (.) из Prelude в терм
-- flip (.) и, выполняя по одной редукции за шаг, найдите нормальную
-- форму этого терма.
-- 
-- На языке лямбда исчисления мы можем переписать flip как:
-- flip = \f -> \x -> \y -> f y x
-- Начнем редукцию
-- flip (.) 
-- ==β 
-- (\f -> \x -> \y -> f y x) (.) 
-- ==β 
-- \x -> \y -> (.) y x 
-- ==β 
-- \x -> \y -> \z -> y (x z)
-- Итого
-- flip (.) ==β \x -> \y -> \z -> y (x z)
-- 
-- На самом деле редукции в предыдущем случае выполнялись не 
-- последовательно (а как рука положит 😀), но зато мы легко 
-- получили ответ. Ниже будем выполнять по одной редукции 
-- за шаг как положено и на самом деле (спойлер)
-- ответы совпадут 😎
--
--  Имеем
--  flip (.)
--  Начнем совершать β редукции
-- (\f -> \x -> \y -> f y x) (\b -> \k -> \z -> b (k z))
--  β редукция
-- \x -> \y -> (\b -> \k -> \z -> b (k z)) y x
--  β редукция
-- \x -> \y -> (\k -> \z -> y (k z)) x
--  β редукция
-- \x -> \y -> (\z -> y (x z))
--  так как тело лямбда абстракции простирается до конца вправо,
--  скобки тут не нужны
-- \x -> \y -> \z -> y (x z)
